outputs <- "y1"
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance$train.SSVF()
library(svfpackage2)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(5, 4, 3, 5), y2 = c(3, 1, 2, 4))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")  # x2 no existe en los datos, suponemos un error o falta de datos
outputs <- "y1"
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")  # x2 no existe en los datos, suponemos un error o falta de datos
outputs <- "y1"
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- "x1"  # x2 no existe en los datos, suponemos un error o falta de datos
outputs <- "y1"
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
library(svfpackage2)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(5, 4, 3, 5), y2 = c(3, 1, 2, 4))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
print(svf_instance$solution$w)
library(svfpackage2)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(5, 4, 3, 5), y2 = c(3, 1, 2, 4))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
print(svf$solution$w)
# Probar la función get_estimation
estimations <- list(
svf$get_estimation(c(1, 2)),
svf$get_estimation(c(3, 4)),
svf$get_estimation(c(1, 7)),
svf$get_estimation(c(7, 1)),
svf$get_estimation(c(2, 4)),
svf$get_estimation(c(7, 1))
)
library(svfpackage2)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(5, 4, 3, 5), y2 = c(3, 1, 2, 4))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
print(svf$solution$w)
# Probar la función get_estimation
estimations <- list(
svf$get_estimation(c(1, 2)),
svf$get_estimation(c(3, 4)),
svf$get_estimation(c(1, 7)),
svf$get_estimation(c(7, 1)),
svf$get_estimation(c(2, 4)),
svf$get_estimation(c(7, 1))
)
library(svfpackage2)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Mostrar la frontera de producción (debe definir correctamente la función y ajustar los datos)
plot_production_frontier(svf, data, 'x1', 'y1')
source("~/Documents/GitHub/svfpackage2/R/svf_functions.R")
library(svfpackage2)
source("~/Documents/GitHub/svfpackage2/R/svf_functions.R")
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Mostrar la frontera de producción (debe definir correctamente la función y ajustar los datos)
plot_production_frontier(svf, data, 'x1', 'y1')
library(svfpackage2)
source("~/Documents/GitHub/svfpackage2/R/svf_functions.R")
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Mostrar la frontera de producción (debe definir correctamente la función y ajustar los datos)
plot_production_frontier(svf_instance, data, 'x1', 'y1')
library(svfpackage2)
source("~/Documents/GitHub/svfpackage2/R/svf_functions.R")
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
library(svfpackage2)
source("~/Documents/GitHub/svfpackage2/R/svf_functions.R")
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
library(svfpackage2)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Usar la función para graficar la frontera de producción
plot_production_frontier(svf_instance, "x1", "y1", d)
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Usar la función para graficar la frontera de producción
plot_production_frontier(svf_instance, "x1", "y1", d)
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Usar la función para graficar la frontera de producción
plot_production_frontier(svf_instance, "x1", "y1", d)
library(svfpackage)
library(ggplot2)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Usar la función para graficar la frontera de producción
plot_production_frontier(svf_instance, "x1", "y1", d)
library(svfpackage)
library(ggplot2)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Usar la función para graficar la frontera de producción
plot_production_frontier(svf_instance, "x1", "y1", d)
