usethis::use_mit_license()
source("~/Documents/GitHub/svfpackage2/R/grid.R")
#' Constructor para la clase SVFGrid
#'
#' Esta función crea una instancia de la clase SVFGrid, la cual es una
#' extensión de la clase GRID con funcionalidades adicionales específicas
#' para el manejo de grids en el contexto de análisis SVF.
#'
#' @param data Conjunto de datos sobre los que se construye el grid.
#' @param inputs Listado de inputs.
#' @param outputs Listado de outputs.
#' @param d Número de particiones en las que se divide el grid.
#'
#' @return Un objeto de clase SVFGrid.
#'
#' @example examples/example_svfgrid.R
#'
#' @export
SVFGrid <- function(data, inputs, outputs, d) {
grid <- list(data = data, inputs = inputs, outputs = outputs, d = d, df_grid = data.frame(), data_grid = data.frame())
class(grid) <- c("SVFGrid", "GRID")
return(grid)
}
#' Función que crea un grid en base a unos datos e hiperparámetro d
#'
#' Este método crea un grid basado en los datos y el parámetro d proporcionados
#' al constructor. Este grid es una representación de los datos en un espacio
#' dividido en celdas definidas por el parámetro d.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return El objeto SVFGrid con el grid creado.
#'
#' @example examples/example_create_grid.R
#'
#' @export
create_grid.SVFGrid <- function(grid) {
x <- grid$data[, grid$inputs]
n_dim <- ncol(x)
knot_list <- list()
knot_index <- list()
for (col in seq_len(n_dim)) {
knot_min <- min(x[, col], na.rm = TRUE)
knot_max <- max(x[, col], na.rm = TRUE)
amplitud <- (knot_max - knot_min) / grid$d
knots <- seq(knot_min, knot_max, length.out = grid$d + 1)
knot_list[[col]] <- knots
knot_index[[col]] <- 1:(grid$d + 1)
}
grid$knot_list <- knot_list
id_cells <- expand.grid(knot_index)
id_cells <- id_cells[, ncol(id_cells):1]
values <- expand.grid(rev(knot_list))
values <- values[, ncol(values):1]
grid$df_grid <- list(id_cells = id_cells, values = values, phi = vector("list", nrow(values)))
grid <- calculate_df_grid(grid)
grid <- calculate_data_grid(grid)
return(grid)
}
#' Función que calcula el valor de la transformación (phi) de una observación en el grid.
#'
#' Esta función calcula y retorna el valor de phi para una celda específica del
#' grid, basado en los datos del grid y la posición de la celda.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#' @param cell Posición de la observación en el grid.
#'
#' @return Una lista que contiene los valores de phi para la celda especificada.
#'
#' @example examples/example_phi.R
#'
#' @export
calculate_dmu_phi <- function(grid, cell) {
df_grid <- grid$df_grid
n_rows <- nrow(df_grid$id_cells)
phi_list <- vector("list", length(grid$outputs))
for (output_index in seq_along(grid$outputs)) {
phi <- numeric(n_rows)
for (i in seq_len(n_rows)) {
value <- 1
for (j in seq_along(cell)) {
if (cell[j] < df_grid$id_cells[i, j]) {
value <- 0
break
}
}
phi[i] <- value
}
phi_list[[output_index]] <- phi
}
return(phi_list)
}
#' Método para añadir al dataframe grid el valor de la transformada de cada observación
#'
#' Este método calcula y añade información adicional al dataframe de grid
#' asociado a un objeto SVFGrid. Esta información incluye los valores de phi
#' para cada celda del grid y las celdas contiguas a cada celda.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return El objeto SVFGrid con el dataframe de grid actualizado.
#'
#' @example examples/example_df.R
#'
#' @export
calculate_df_grid <- function(grid) {
n <- nrow(grid$df_grid$id_cells)
phi_list <- vector("list", n)
c_cells_list <- vector("list", n)
for (i in 1:n) {
cell <- grid$df_grid$values[i, , drop = FALSE]
p <- search_dmu.GRID(grid, cell)
phi <- calculate_dmu_phi(grid, p)[[1]]
c_cells <- search_contiguous_cell(p)
phi_list[[i]] <- list(phi)
c_cells_list[[i]] <- c_cells
}
grid$df_grid$phi <- phi_list
grid$df_grid$c_cells <- c_cells_list
return(grid)
}
#' Método para añadir al dataframe grid el valor de la transformada de cada observación
#'
#' Esta función procesa cada observación del data_grid basándose en las columnas especificadas en inputs,
#' calculando valores phi y celdas contiguas (c_cells) y actualizando el objeto grid con estos resultados.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return 0bjeto grid modificado con los resultados de phi y c_cells añadidos.
#'
#' @example examples/example_data.R
#'
#' @export
calculate_data_grid <- function(grid) {
grid$data_grid <- grid$data[, c(grid$inputs, grid$outputs), drop = FALSE]
n_rows <- nrow(grid$data_grid)
phi_list <- vector("list", n_rows)
c_cells_list <- vector("list", n_rows)
for (i in seq_len(n_rows)) {
x <- as.numeric(grid$data_grid[i, grid$inputs, drop = FALSE])
p <- search_dmu.GRID(grid, x)
phi <- calculate_dmu_phi(grid, p)
c_cells <- search_contiguous_cell(p)
phi_list[[i]] <- phi
c_cells_list[[i]] <- c_cells
}
grid$data_grid$phi <- phi_list
grid$data_grid$c_cells <- c_cells_list
return(grid)
}
#' Buscar celdas contiguas en SVFGrid
#'
#' Esta función identifica y retorna las celdas contiguas a una celda especificada
#' en el grid. Las celdas contiguas son aquellas que comparten al menos un borde
#' o punto con la celda especificada.
#'
#' @param cell Vector que especifica la posición de la celda en el grid.
#'
#' @return Una lista de celdas contiguas a la especificada.
#'
#' @example examples/example_contiguous.R
#'
#' @export
search_contiguous_cell <- function(cell) {
con_c_list <- list()
for (dim in seq_along(cell)) {
value <- cell[dim] - 1
if (value >= 1) {
con_cell <- cell
con_cell[dim] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
#' Crea una nueva instancia de la clase SVF
#'
#' Esta función inicializa un objeto SVF con los parámetros proporcionados,
#' encapsulando un modelo SVF con las especificaciones de entrada y salida,
#' junto con los hiperparámetros del modelo.
#'
#' @param method Método SVF que se quiere utilizar.
#' @param inputs Inputs a evaluar en el conjunto de datos.
#' @param outputs Outputs a evaluar en el conjunto de datos.
#' @param data Conjunto de datos a evaluar.
#' @param C Valores del hiperparámetro C del modelo.
#' @param eps Valores del hiperparámetro épsilon del modelo.
#' @param d Valor del hiperparámetro d del modelo.
#'
#' @return Un objeto de la clase 'SVF'.
#'
#' @example examples/example_svf.R
#'
#' @export
SVF <- function(method, inputs, outputs, data, C, eps, d) {
structure(list(method = method, inputs = inputs, outputs = outputs, data = data, C = C, eps = eps, d = d), class = "SVF")
}
install.packages("ROI.plugin.glpk")
source("~/Documents/GitHub/svfpackage2/R/svfgrid.R")
source("~/Documents/GitHub/svfpackage2/R/svf.R")
library(ROI)
library(ROI.plugin.glpk)
#' Crea un objeto SSVF
#'
#' @param method Método SVF a utilizar.
#' @param inputs Inputs a evaluar en el conjunto de datos.
#' @param outputs Outputs a evaluar en el conjunto de datos.
#' @param data Conjunto de datos a evaluar.
#' @param c Valores del hiperparámetro C del modelo.
#' @param eps Valores del hiperparámetro épsilon del modelo.
#' @param d Valor del hiperparámetro d del modelo.
#'
#' @return Un objeto de clase SSVF.
#'
#' @example examples/example_ssvf.R
#'
#' @export
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
#' Entrena el modelo SSVF
#'
#' Esta función configura y resuelve el modelo SSVF utilizando programación lineal mixta.
#'
#' @param svf Objeto SSVF.
#'
#' @return El objeto SSVF con el modelo resuelto añadido.
#'
#' @example examples/example_train.R
#'
#' @import Rcplex
#'
#' @export
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
total_variables <- n_out * n_var + n_out * n_obs
cvec <- c(rep(1, n_out * n_var), rep(svf$c, n_out * n_obs))
Amat <- matrix(0, nrow = 2 * n_out * n_obs, ncol = total_variables)
bvec <- vector("numeric", length = 2 * n_out * n_obs)
sense <- rep("<=", 2 * n_out * n_obs)
for (out in 1:n_out) {
for (obs in 1:n_obs) {
phi_vector <- svf$grid$data_grid$phi[[obs]][[out]]
row_index1 <- (out - 1) * 2 * n_obs + (obs - 1) * 2 + 1
row_index2 <- row_index1 + 1
w_indices <- ((out - 1) * n_var + 1):((out - 1) * n_var + n_var)
xi_index <- n_out * n_var + (out - 1) * n_obs + obs
Amat[row_index1, w_indices] <- -phi_vector
Amat[row_index2, w_indices] <- phi_vector
Amat[row_index2, xi_index] <- -1
bvec[row_index1] <- -y[obs, out]
bvec[row_index2] <- y[obs, out] + svf$eps
}
}
# Define the optimization problem without specifying variable names
problem <- OP(objective = L_objective(cvec),
constraints = L_constraint(Amat, sense, bvec),
types = rep("C", total_variables))
svf$model <- ROI_solve(problem, solver = "glpk")
return(svf)
}
#' Resolver el modelo SSVF
#'
#' Esta función extrae las soluciones del modelo SSVF después de que ha sido resuelto.
#'
#' @param svf Objeto SSVF con un modelo ya entrenado.
#'
#' @return Una lista conteniendo las soluciones para las variables 'w' y 'xi'.
#'
#' @example examples/example_solve.R
#'
#' @export
solve <- function(svf) {
solution <- svf$model$solution
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
n_out <- length(svf$outputs)
n_obs <- nrow(svf$data)
n_w_vars <- n_out * n_var
n_xi_vars <- n_out * n_obs
w_solution <- solution[1:n_w_vars]
xi_solution <- solution[(n_w_vars + 1):(n_w_vars + n_xi_vars)]
mat_w <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_var + 1
end_index <- out * n_var
mat_w[[out]] <- round(w_solution[start_index:end_index], 6)
}
mat_xi <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
mat_xi[[out]] <- round(xi_solution[start_index:end_index], 6)
}
cat("Solucion para w variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [%s]\n", paste(mat_w[[out]], collapse=", ")))
}
cat("Solucion para xi variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [%s]\n", paste(mat_xi[[out]], collapse=", ")))
}
return(list(w = mat_w, xi = mat_xi))
}
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(5, 4, 3, 5), y2 = c(3, 1, 2, 4))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage2/R/ssvf.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(5, 4, 3, 5), y2 = c(3, 1, 2, 4))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage2/R/svfgrid.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj <- create_grid.SVFGrid(grid_obj)
# Imprimimos la knot_list
cat("knot_list:\n")
for (i in seq_along(grid_obj$knot_list)) {
cat(paste0("Dimensión ", i, " (", names(grid_obj$knot_list)[i], "): "),
paste(sprintf("%.1f", grid_obj$knot_list[[i]]), collapse = ", "), "\n")
}
# Realizar una búsqueda en el grid para una observación
dmu <- c(1, 3 )
position <- search_dmu.GRID(grid_obj, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Ejemplo de búsqueda de celda contigua
cell <- c(1, 1)
contiguous_cells <- search_contiguous_cell(cell)
print(paste("Celdas contiguas: (", paste(contiguous_cells, collapse = ", "), ")", sep = ""))
# Ejemplo del calculo de phi para una celda dada
cell <- c(1, 3)
phi_list <- calculate_dmu_phi(grid_obj, cell)
print("Vector phi para la celda dada:")
print(phi_list)
print_df_grid <- function(df_grid) {
print("DF grid completo:")
temp_df <- data.frame(
id_cell = apply(df_grid$id_cells, 1, function(row) paste0("(", paste(row, collapse = ", "), ")")),
value = apply(df_grid$values, 1, function(row) paste0("(", paste(sprintf("%.1f", row), collapse = ", "), ")")),
phi = sapply(df_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse=" "))),
c_cells = sapply(df_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_df_grid(grid_obj$df_grid)
print_data_grid <- function(data_grid) {
print("Data grid completo:")
temp_df <- data.frame(
x1 = data_grid$x1,
x2 = data_grid$x2,
phi = sapply(data_grid$phi, function(phi) sprintf("[%s]", paste(phi, collapse = " "))),
c_cells = sapply(data_grid$c_cells, function(cells) if (length(cells) > 0) {
paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ")
} else "[]")
)
print(temp_df)
}
print_data_grid(grid_obj$data_grid)
source("~/Documents/GitHub/svfpackage2/R/svf.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
C <- 1
eps <- 0
d <- 2
method <- 'SVF'
# Crear una instancia de la clase SVF
svf <- SVF(method, inputs, outputs, data, C, eps, d)
# Imprimir la instancia
print(svf)
source("~/Documents/GitHub/svfpackage2/R/ssvf.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(5, 4, 3, 5), y2 = c(3, 1, 2, 4))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage2/R/grid.R")
library(ggplot2)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
grid_instance <- GRID(data, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(3, 4)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, data, dmu)
source("~/Documents/GitHub/svfpackage2/R/svf_functions.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
source("~/Documents/GitHub/svfpackage2/R/svf_functions.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
print(solution_svf)
use_readme_md()
library(usethis)
use_readme_md()
