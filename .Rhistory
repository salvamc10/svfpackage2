# Ejemplo de búsqueda de celda contigua
cell <- c(1, 1)
contiguous_cells <- search_contiguous_cell(cell)
print(paste("Celdas contiguas: (", paste(contiguous_cells, collapse = ", "), ")", sep = ""))
# Ejemplo del calculo de phi para una celda dada
cell <- c(1, 3)
phi_list <- calculate_dmu_phi(grid_obj, cell)
print("Vector phi para la celda dada:")
print(phi_list)
print_df_grid <- function(df_grid) {
print("DF grid completo:")
temp_df <- data.frame(
id_cell = apply(df_grid$id_cells, 1, function(row) paste0("(", paste(row, collapse = ", "), ")")),
value = apply(df_grid$values, 1, function(row) paste0("(", paste(sprintf("%.1f", row), collapse = ", "), ")")),
phi = sapply(df_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse=" "))),
c_cells = sapply(df_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_df_grid(grid_obj$df_grid)
print_data_grid <- function(data_grid) {
print("Data grid completo:")
temp_df <- data.frame(
x1 = data_grid$x1,
x2 = data_grid$x2,
phi = sapply(data_grid$phi, function(phi) sprintf("[%s]", paste(phi, collapse = " "))),
c_cells = sapply(data_grid$c_cells, function(cells) if (length(cells) > 0) {
paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ")
} else "[]")
)
print(temp_df)
}
print_data_grid(grid_obj$data_grid)
library(ggplot2)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
grid_instance <- GRID(data, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(3, 4)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, data, dmu)
library(ggplot2)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
grid_instance <- GRID(data, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(3, 4)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, data, dmu)
remove.packages("svfpackage2")
library(ggplot2)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
grid_instance <- GRID(data, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(3, 4)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, data, dmu)
#' Función que crea un objeto del tipo SVF en función del método que se selecciona
#'
#' Esta función es un constructor que permite crear diferentes tipos de objetos SVF.
#' Actualmente, solo soporta el tipo 'SSVF', pero puede ser extendida para incluir
#' otros tipos. Si el método especificado no es soportado, se producirá un error.
#'
#' @param method Método SVF que se quiere utilizar.
#' @param inputs Inputs a evaluar en el conjunto de datos.
#' @param outputs Outputs a evaluar en el conjunto de datos.
#' @param data Conjunto de datos a evaluar.
#' @param c Valores del hiperparámetro C del modelo.
#' @param eps Valores del hiperparámetro épsilon del modelo.
#' @param d Valor del hiperparámetro d del modelo.
#'
#' @return Devuelve un objeto del método SVF seleccionado.
#'
#' @export
create_SVF <- function(method, inputs, outputs, data, c, eps, d) {
if (method == "SSVF") {
svf <- SSVF(method, inputs, outputs, data, c, eps, d)
} else {
stop("The method selected doesn't exist")
}
return(svf)
}
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage2/data/datos2.txt", header = TRUE, sep = ";")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage2/data/datos2.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage2/data/datos2.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
#' Constructor para la clase SVFGrid
#'
#' Esta función crea una instancia de la clase SVFGrid, la cual es una
#' extensión de la clase GRID con funcionalidades adicionales específicas
#' para el manejo de grids en el contexto de análisis SVF.
#'
#' @param data Conjunto de datos sobre los que se construye el grid.
#' @param inputs Listado de inputs.
#' @param outputs Listado de outputs.
#' @param d Número de particiones en las que se divide el grid.
#'
#' @return Un objeto de clase SVFGrid.
#'
#' @example examples/example_svfgrid.R
#'
#' @export
SVFGrid <- function(data, inputs, outputs, d) {
grid <- list(data = data, inputs = inputs, outputs = outputs, d = d, df_grid = data.frame(), data_grid = data.frame())
class(grid) <- c("SVFGrid", class(grid))
return(grid)
}
#' Función que crea un grid en base a unos datos e hiperparámetro d
#'
#' Este método crea un grid basado en los datos y el parámetro d proporcionados
#' al constructor. Este grid es una representación de los datos en un espacio
#' dividido en celdas definidas por el parámetro d.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return El objeto SVFGrid con el grid creado.
#'
#' @example examples/example_create_grid.R
#'
#' @export
create_grid.SVFGrid <- function(grid) {
x <- grid$data[, grid$inputs]
n_dim <- ncol(x)
knot_list <- list()
knot_index <- list()
for (col in seq_len(n_dim)) {
knot_min <- min(x[, col], na.rm = TRUE)
knot_max <- max(x[, col], na.rm = TRUE)
amplitud <- (knot_max - knot_min) / grid$d
knots <- seq(knot_min, knot_max, length.out = grid$d + 1)
knot_list[[col]] <- knots
knot_index[[col]] <- 1:(grid$d + 1)
}
grid$knot_list <- knot_list
id_cells <- expand.grid(knot_index)
id_cells <- id_cells[, ncol(id_cells):1]
values <- expand.grid(rev(knot_list))
values <- values[, ncol(values):1]
grid$df_grid <- list(id_cells = id_cells, values = values, phi = vector("list", nrow(values)))
grid <- calculate_df_grid(grid)
grid <- calculate_data_grid(grid)
return(grid)
}
#' Función que calcula el valor de la transformación (phi) de una observación en el grid.
#'
#' Esta función calcula y retorna el valor de phi para una celda específica del
#' grid, basado en los datos del grid y la posición de la celda.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#' @param cell Posición de la observación en el grid.
#'
#' @return Una lista que contiene los valores de phi para la celda especificada.
#'
#' @example examples/example_phi.R
#'
#' @export
calculate_dmu_phi <- function(grid, cell) {
df_grid <- grid$df_grid
n_rows <- nrow(df_grid$id_cells)
phi_list <- vector("list", length(grid$outputs))
for (output_index in seq_along(grid$outputs)) {
phi <- numeric(n_rows)
for (i in seq_len(n_rows)) {
value <- 1
for (j in seq_along(cell)) {
if (cell[j] < df_grid$id_cells[i, j]) {
value <- 0
break
}
}
phi[i] <- value
}
phi_list[[output_index]] <- phi
}
return(phi_list)
}
#' Método para añadir al dataframe grid el valor de la transformada de cada observación
#'
#' Este método calcula y añade información adicional al dataframe de grid
#' asociado a un objeto SVFGrid. Esta información incluye los valores de phi
#' para cada celda del grid y las celdas contiguas a cada celda.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return El objeto SVFGrid con el dataframe de grid actualizado.
#'
#' @example examples/example_df.R
#'
#' @export
calculate_df_grid <- function(grid) {
n <- nrow(grid$df_grid$id_cells)
phi_list <- vector("list", n)
c_cells_list <- vector("list", n)
for (i in 1:n) {
cell <- grid$df_grid$values[i, , drop = FALSE]
p <- search_dmu.GRID(grid, cell)
phi <- calculate_dmu_phi(grid, p)[[1]]
c_cells <- search_contiguous_cell(p)
phi_list[[i]] <- list(phi)
c_cells_list[[i]] <- c_cells
}
grid$df_grid$phi <- phi_list
grid$df_grid$c_cells <- c_cells_list
return(grid)
}
#' Método para añadir al dataframe grid el valor de la transformada de cada observación
#'
#' Esta función procesa cada observación del data_grid basándose en las columnas especificadas en inputs,
#' calculando valores phi y celdas contiguas (c_cells) y actualizando el objeto grid con estos resultados.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return 0bjeto grid modificado con los resultados de phi y c_cells añadidos.
#'
#' @example examples/example_data.R
#'
#' @export
calculate_data_grid <- function(grid) {
grid$data_grid <- grid$data[, c(grid$inputs, grid$outputs), drop = FALSE]
n_rows <- nrow(grid$data_grid)
phi_list <- vector("list", n_rows)
c_cells_list <- vector("list", n_rows)
for (i in seq_len(n_rows)) {
x <- as.numeric(grid$data_grid[i, grid$inputs, drop = FALSE])
p <- search_dmu.GRID(grid, x)
phi <- calculate_dmu_phi(grid, p)
c_cells <- search_contiguous_cell(p)
phi_list[[i]] <- phi
c_cells_list[[i]] <- c_cells
}
grid$data_grid$phi <- phi_list
grid$data_grid$c_cells <- c_cells_list
return(grid)
}
#' Buscar celdas contiguas en SVFGrid
#'
#' Esta función identifica y retorna las celdas contiguas a una celda especificada
#' en el grid. Las celdas contiguas son aquellas que comparten al menos un borde
#' o punto con la celda especificada.
#'
#' @param cell Vector que especifica la posición de la celda en el grid.
#'
#' @return Una lista de celdas contiguas a la especificada.
#'
#' @example examples/example_contiguous.R
#'
#' @export
search_contiguous_cell <- function(cell) {
con_c_list <- list()
for (dim in seq_along(cell)) {
value <- cell[dim] - 1
if (value >= 1) {
con_cell <- cell
con_cell[dim] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage2/data/datos2.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj <- create_grid.SVFGrid(grid_obj)
library(ggplot2)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage2/data/datos2.txt", header = TRUE, sep = ";")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
grid_instance <- GRID(data, inputs, outputs, d)
sorce("GRID.R")
sorce("grid.R")
source("grid.R")
source("GRID.R")
source("~/Documents/GitHub/svfpackage2/R/grid.R", echo=TRUE)
source("~/Documents/GitHub/svfpackage2/R/grid.R")
source("~/R/grid.R")
# install.packages("devtools")
devtools::install_github("salvamc10/svfpackage2")
library(svfpackage2)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage2/data/datos2.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
library(svfpackage2)
# Usar datos de prueba
data(datos, package = "svfpackage")
library(svfpackage2)
# Usar datos de prueba
data(datos, package = "svfpackage2")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
library(svfpackage2)
# Usar datos de prueba
data(datos2, package = "svfpackage2")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, datos2, C, eps, d)
library(svfpackage2)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(5, 4, 3, 5), y2 = c(3, 1, 2, 4)
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
library(svfpackage2)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(5, 4, 3, 5), y2 = c(3, 1, 2, 4))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
